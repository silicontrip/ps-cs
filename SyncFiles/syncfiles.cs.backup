using System.Management.Automation;  // Windows PowerShell assembly.
using System.Management.Automation.Runspaces;
//using System.Management.Automation.Runspaces.Pipeline;
using System;
using System.IO;
using System.Linq;
using System.Collections.ObjectModel;
using System.Security;


namespace SyncPath
{
	public interface IO {

        Collection<string> ReadDir(string p);
		void MakeDir(string p);
        FileInfo GetFileInfo(string p);
		FileAttributes GetAttributes(string p);
		byte[] ReadBlock(string p, int block);  // this might need a file handle, windows open and close is quite expensive, unlike other OS
		void WriteBlock(string p, int block, byte[] data); // file handle?
		string HashBlock(string p, int block); // file handle
		string HashTotal(string p);
	};	

	public class LocalIO : IO {
        public readonly static int g_blocksize = 1048576;
        public Collection<string> ReadDir (string p)
		{
            // may need to use EnumerateFiles
            // string[] dir = System.IO.Directory.GetDirectory(p, "*", System.IO.SearchOption.AllDirectories);
            // string[] files = System.IO.Directory.GetFiles(p, "*", System.IO.SearchOption.AllDirectories);

            string[] entry = System.IO.Directory.GetFileSystemEntries(p, "*", System.IO.SearchOption.AllDirectories);
            return new Collection<string>(entry);
		}

		public void MakeDir(string p)
		{
			System.IO.Directory.CreateDirectory(p);
		}
		public FileAttributes GetAttributes(string p)
		{
			return System.IO.File.GetAttributes(p);
		}
        public FileInfo GetFileInfo(string p)
        {
            return new FileInfo(p);
        }
		public string HashTotal (string p)
		{
			using (FileStream stream = System.IO.File.OpenRead(p))
			{
				System.Security.Cryptography.SHA256 sha = System.Security.Cryptography.SHA256.Create();
				byte[] bytehash;
				bytehash=sha.ComputeHash(stream);
				string result = "";
				foreach (byte b in bytehash) result += b.ToString("x2");
                sha.Dispose();
				return result;	
			}
		}
        // how to handle short blocks
		public byte[] ReadBlock (string p, int block) 
		{
			System.IO.FileStream fs = System.IO.File.Open(p,System.IO.FileMode.Open);
			Int64 bloffset = block * g_blocksize;  
			
			fs.Seek(bloffset, System.IO.SeekOrigin.Begin);
			Byte[] b = new Byte[g_blocksize];
		
			Int32 br = fs.Read(b,0,g_blocksize);
            if (br!=g_blocksize)
                Array.Resize(ref b, br);

            fs.Dispose();

			return b;

		}
		public void WriteBlock (string p, int block, byte[] data) 
		{
			System.IO.FileStream fs = System.IO.File.Open(p,System.IO.FileMode.Append);
			Int64 bloffset = block * g_blocksize;

            Int32 bytes = data.Length;

			fs.Seek (bloffset,System.IO.SeekOrigin.Begin); // cannot seek to data already written
			fs.Write(data,0,bytes);

            fs.Dispose();
			
		} // cater for short blocks
		public string HashBlock (string p , int block) 
		{
			System.IO.FileStream fs = System.IO.File.Open(p,System.IO.FileMode.Open);
			Int64 bloffset = block * g_blocksize;  
			
			fs.Seek(bloffset, System.IO.SeekOrigin.Begin);  // hopefully throws when seeking beyond end of file.
			Byte[] b = new Byte[g_blocksize];
		
			int num = fs.Read(b,0,g_blocksize);
            fs.Dispose();

			System.Security.Cryptography.SHA256 sha = System.Security.Cryptography.SHA256.Create();
			byte[] bytehash;  

			bytehash=sha.ComputeHash(b,0,num);
            sha.Dispose();
			string result = "";
			foreach (byte bb in bytehash) result += bb.ToString("x2");
			return result;	
		}

			
	}

	public class RemoteIO : IO {
        public readonly static int g_blocksize = 1048576;
        readonly PSSession session;
		public RemoteIO (PSSession s) 
		{  
			session = s; 
		}

		public Collection<string> ReadDir (string p)
		{
			string format = "[System.IO.Directory]::GetFileSystemEntries(\"{0}\",\"*\",[System.IO.Searchoption]::AllDirectories)";
			string command = string.Format(format,p);

            Pipeline pipe = session.Runspace.CreatePipeline();
            pipe.Commands.AddScript(command);
			Collection<PSObject> rv= pipe.Invoke();
			Collection<string> ret = new Collection<string>();

			foreach (PSObject ps in rv) { ret.Add(ps.ToString()); }
			return ret;

		}
		public void MakeDir (string p)
		{
			string format = "[System.IO.Directory]::CreateDirectory(\"{0}\")";
			string command = string.Format(format,p);
            Pipeline pipe = session.Runspace.CreatePipeline();

            pipe.Commands.AddScript(command);
			pipe.Invoke();
		}
		public FileAttributes GetAttributes(string p) 
		{
			string format = "[System.IO.File]::GetAttributes(\"{0}\")";
			string command = string.Format(format,p);
            Pipeline pipe = session.Runspace.CreatePipeline();

            pipe.Commands.AddScript(command);
			Collection<PSObject> res = pipe.Invoke();
			// how to get back to a FileAttributes
			foreach (PSObject ps in res)
				return (FileAttributes)ps.BaseObject;
			// or perhaps throw error
			return new FileAttributes();
			
		}
		public FileInfo GetFileInfo(string p) 
		{

			string format = "[System.IO.FileInfo]::New(\"{0}\")";
			string command = string.Format(format,p);
            Pipeline pipe = session.Runspace.CreatePipeline();
    
            pipe.Commands.AddScript(command);
			Collection<PSObject> res = pipe.Invoke();
			foreach (PSObject ps in res)
				return (FileInfo)ps.BaseObject;
			// throw error
          //  throw new Fil
			return null;
		}

		public string HashTotal(string p) 
		{
			string format = "$fs=[System.IO.file]::OpenRead(\"{0}\")";
			string command = string.Format(format,p);
            Pipeline pipe = session.Runspace.CreatePipeline();

            pipe.Commands.AddScript(command);
    
			pipe.Commands.AddScript( "$sha=[system.security.cryptography.sha256]::Create()" );
			pipe.Commands.AddScript( "$sha.computehash($fs)");
			Collection<PSObject> res = pipe.Invoke();
			byte[] bytes;
			foreach (PSObject ps in res)
			{
				bytes=(System.Byte[])ps.BaseObject;

				string result = "";
				foreach (byte b in bytes) result += b.ToString("x2");
				return result;				
			}
			return null;

		}

		public byte[] ReadBlock (string p, int block) 
		{
			string format = "$fs=[System.IO.file]::Open(\"{0}\",[System.IO.FileMode]::Open)";
			string command = string.Format(format,p);
            Pipeline pipe = session.Runspace.CreatePipeline();
    
            pipe.Commands.AddScript(command);

			Int64 bloffset = block * g_blocksize;

			string format2 = "$fs.Seek({0},[System.IO.SeekOrigin]::Begin)";
			string command2 = string.Format(format2,bloffset);
			pipe.Commands.AddScript(command2);

			string format3 = "$b=[System.byte[]]::new({0})";
			string command3 = string.Format(format3,g_blocksize);
			pipe.Commands.AddScript(command3);

			//pipe.Commands.AddScript( "$b=[System.byte[]]::new({0})" );
			pipe.Commands.AddScript( "$r=$f.read($b,0,1048576)" );

			//Collection<PSObject> bytesres = pipe.Invoke();
			pipe.Commands.AddScript( "[Convert]::ToBase64String($b)" );
			Collection<PSObject> res = pipe.Invoke();
			foreach (PSObject ps in res)
				return (byte[])ps.BaseObject;

			return null;
		}
		public void WriteBlock (string p, int block, byte[] data) {
            string format = "$fs=[System.IO.file]::Open(\"{0}\",[System.IO.FileMode]::Append)";
            string command = string.Format(format, p);
            Pipeline pipe = session.Runspace.CreatePipeline();

            pipe.Commands.AddScript(command);

            Int64 bloffset = block * g_blocksize;

            string format2 = "$fs.Seek({0},[System.IO.SeekOrigin]::Begin)";
            string command2 = string.Format(format2, bloffset);
            pipe.Commands.AddScript(command2);

            string b64data = System.Convert.ToBase64String(data);

            string format3 = "$b=[Convert]::FromBase64String(\"{0}\")";
            string command3 = string.Format(format3, b64data);
            pipe.Commands.AddScript(command3);

           // pipe.Commands.AddScript("$b=[System.byte[]]::new({0})");
            pipe.Commands.AddScript("$fs.write($b,0,$b.Length)");

            //Collection<PSObject> bytesres = pipe.Invoke();
            //pipe.Commands.AddScript("$b");
           // Collection<PSObject> res = 
                pipe.Invoke();

        }
		public string HashBlock (string p , int block) {
			string format = "$fs=[System.IO.file]::Open(\"{0}\",[System.IO.FileMode]::Open)";
			string command = string.Format(format,p);
            Pipeline pipe = session.Runspace.CreatePipeline();
    
            pipe.Commands.AddScript(command);

			Int64 bloffset = block * g_blocksize;

			string format2 = "$fs.Seek({0},[System.IO.SeekOrigin]::Begin)";
			string command2 = string.Format(format2,bloffset);
			pipe.Commands.AddScript(command2);

			string format3 = "$b=[System.byte[]]::new({0})";
			string command3 = string.Format(format3,g_blocksize);
			pipe.Commands.AddScript(command3);

			pipe.Commands.AddScript( "$b=[System.byte[]]::new({0})" );
			pipe.Commands.AddScript( "$r=$f.read($b,0,1048576)" );
			pipe.Commands.AddScript( "$sha=[system.security.cryptography.sha256]::Create()" );
			pipe.Commands.AddScript( "$sha.computehash($b,0,$r)");

			Collection<PSObject> res = pipe.Invoke();
			foreach (PSObject ps in res)
			{
				byte[] bytes = (byte[])ps.BaseObject;
				string result = "";
				foreach (byte b in bytes) result += b.ToString("x2");
				return result;				
			}
			return null;
		}

	}
  // Declare the class as a cmdlet and specify the
  // appropriate verb and noun for the cmdlet name.
	[Cmdlet(VerbsData.Sync, "ChildItems")]
	public class SyncPathCommand : PSCmdlet
	{
		// Declare the parameters for the cmdlet.
		[Parameter(Mandatory=true,Position=0)]
		public string Path
		{
			get { return path; }
			set { path = value; }
		}
		private string path;

		[Parameter(Mandatory=true,Position=1)]
		public string Target
		{
			get { return target; }
			set { target = value; }
		}
		private string target;

		[Parameter()]
		public PSSession ToSession
		{
			get { return tosession; }
			set { tosession = value; }
		}
		private PSSession tosession;

		[Parameter()]
		public PSSession FromSession
		{
			get { return fromsession; }
			set { fromsession = value; }
		}
		private PSSession fromsession;
// .net standard 2.0 does not have this function
// taken from  https://stackoverflow.com/questions/275689/how-to-get-relative-path-from-absolute-path/340454#340454
public String MakeRelativePath(String fromPath, String toPath)
{


    if (String.IsNullOrEmpty(fromPath)) throw new ArgumentNullException("fromPath");
    if (String.IsNullOrEmpty(toPath))   throw new ArgumentNullException("toPath");

    Uri fromUri = new Uri(fromPath);
    Uri toUri = new Uri(toPath);

    if (fromUri.Scheme != toUri.Scheme) { return toPath; } // path can't be made relative.

    Uri relativeUri = fromUri.MakeRelativeUri(toUri);
    String relativePath = Uri.UnescapeDataString(relativeUri.ToString());

    if (toUri.Scheme.Equals("file", StringComparison.InvariantCultureIgnoreCase))
    {
        relativePath = relativePath.Replace(System.IO.Path.AltDirectorySeparatorChar, System.IO.Path.DirectorySeparatorChar);
    }
           // WriteDebug(String.Format("MakeRelativePath {0} -> {1} = {2}\n", fromPath, toPath, relativePath));

            return relativePath;
}

// Override the ProcessRecord method to process
// the supplied user name and write out a
// greeting to the user by calling the WriteObject
// method.
		protected override void ProcessRecord()
		{

			IO src;
			IO dst;

			Collection<string> filelist;

			if (fromsession != null) { 
				src = new RemoteIO (fromsession);
			} else { 
				src = new LocalIO ();
			}

			if (tosession != null) {
				dst = new RemoteIO (tosession);
			} else { 
				dst = new LocalIO();
			}

            
          WriteDebug(String.Format("Arguments {0} -> {1}\n", path, target));

            string curPath = this.SessionState.Path.CurrentFileSystemLocation.ToString(); //System.IO.Directory.GetCurrentDirectory();
            string abspath = System.IO.Path.Combine(curPath,path);

            WriteDebug(String.Format("ABSPATH {0}", abspath));

            try
            {
                dst.GetAttributes(target);
            }
            catch (Exception) // remote throws different exception to local
            {
                WriteDebug(String.Format("exception MakeDir {0}", target));
                dst.MakeDir(target);
            }

            try
            {

                filelist = src.ReadDir(abspath);

                foreach (string file in filelist)
                {
                    try
                    {
                        string relfile = MakeRelativePath(abspath, file);
                        string dstfile = System.IO.Path.Combine(target, relfile);
                        //      WriteDebug(String.Format("file: {0} target: {1} rel: {2}", file,target,relfile));


                        // file or dir ?
                        if ((src.GetAttributes(file) & System.IO.FileAttributes.Directory) != 0)
                        {
                            WriteDebug(String.Format("src isDir: {0}", file));
                            try
                            {
                                dst.GetAttributes(dstfile);
                            }
                            catch (Exception)  
                            {
                                WriteDebug(String.Format("exception MakeDir {0}", dstfile));
                                WriteVerbose(String.Format("{0}", dstfile));

                                dst.MakeDir(dstfile);
                            }
                        }
                        else
                        {
                            WriteDebug(String.Format("Compare and Copy from {1} to {0}", dstfile, file));

                            // check if dst exists

                            // compare relfile	
                            FileInfo srcInfo = src.GetFileInfo(file);
                            FileInfo dstInfo;
                            try
                            {
                                dstInfo = dst.GetFileInfo(dstfile);
                                // length
                                // last write time
                                if (
                                    (srcInfo.Length != dstInfo.Length) ||
                                    (srcInfo.LastWriteTime > dstInfo.LastWriteTime)
                                   )
                                {
                                    WriteDebug(String.Format("size or date mismatch {1} to {0}", dstfile, file));
                                    WriteVerbose(String.Format("{0} -> {1}\n", relfile, dstfile));

                                    // copy

                                }
                                else
                                {
                                    // total hash
                                    WriteDebug(String.Format("Hash Compare {1} to {0}", dstfile, file));

                                    string srcHash = src.HashTotal(file);
                                    string dstHash = dst.HashTotal(dstfile);
                                    if (srcHash != dstHash)
                                    {
                                        WriteDebug("file hash mismatch");
                                        WriteVerbose(String.Format("{0} -> {1}\n", relfile, dstfile));

                                        // check src and dst block
                                        // read block until less than blocksize
                                        // write block. 
                                        //optinal sync attributes and dates and acl
                                        // update progress
                                    }
                                    else
                                    {
                                        WriteDebug("file hash match");
                                        WriteVerbose(String.Format("Skipping {0}", file));
                                    }
                                }

                            }
                            catch (Exception)
                            {
                                WriteDebug("dst not exists copy new");
                                WriteVerbose(String.Format("{0} -> {1}\n", relfile, dstfile));

                                // read block until less than blocksize
                                // write block. 

                                Int32 block = 0;
                                Byte[] b;
                                do
                                {
                                    b = src.ReadBlock(file, block);
                                    dst.WriteBlock(dstfile, block, b);
                                    // update progress
                                }
                                while (b.Length == LocalIO.g_blocksize);



                                //optinal sync attributes and dates and acl
                                // update progress
                            }



                        }

                    } catch (Exception e)
                    {

                        ErrorRecord er = new ErrorRecord(e, "general", ErrorCategory.ObjectNotFound, null);
                        WriteError(er);
                    }
                }
            } catch (Exception e)
            {
                ErrorRecord er = new ErrorRecord(e,"general",ErrorCategory.ObjectNotFound,null);
                WriteError(er);
            }

		}

	}

}
